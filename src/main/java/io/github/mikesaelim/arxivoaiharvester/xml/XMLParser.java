package io.github.mikesaelim.arxivoaiharvester.xml;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Lists;
import io.github.mikesaelim.arxivoaiharvester.exception.HarvesterError;
import io.github.mikesaelim.arxivoaiharvester.exception.ParseException;
import io.github.mikesaelim.arxivoaiharvester.model.data.ArticleMetadata;
import io.github.mikesaelim.arxivoaiharvester.model.data.ArticleVersion;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.openarchives.oai._2.OAIPMHtype;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.UnmarshalException;
import javax.xml.bind.Unmarshaller;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import java.io.File;
import java.io.InputStream;
import java.time.ZonedDateTime;
import java.util.List;

/**
 * Parses the XML response from arXiv's OAI repository into a {@link ParsedXmlResponse}.  The XML response must
 * <ul>
 *     <li>satisfy the OAI-PMH v2.0 XML schema,</li>
 *     <li>be a response for either the verb "GetRecord" or the verb "ListRecords", and</li>
 *     <li>have metadata satisfying arXiv's XML schema for the "arXivRaw" metadata format (the current version of that
 *     is 2014-06-24).</li>
 * </ul>
 *
 * Internally, the XML is parsed in two steps:
 * <ol>
 *     <li>the XML is unmarshalled into autogenerated data objects by the JAXB parser, and then </li>
 *     <li>these data objects are parsed into {@link ArticleVersion}, {@link ArticleMetadata}, and
 *     {@link ParsedXmlResponse} objects.</li>
 * </ol>
 * Additionally, we have to deal with corrupted XML input that contains spurious line breaks in the middle of some of
 * the string values.  For this reason, we normalize the string values that we extract.
 *
 * TODO sample usage
 */
@Slf4j
public class XMLParser {

    // TODO: handle warnings, errors, etc. from the parser
    // TODO: handle error responses from the repository

    Unmarshaller unmarshaller;

    /**
     * Constructs a new XML parser by initializing the JAXB unmarshaller and setting up the XML validation.
     *
     * @throws HarvesterError if there are any problems
     */
    public XMLParser() {
        try {
            unmarshaller = JAXBContext.newInstance("org.openarchives.oai._2:org.arxiv.oai.arxivraw")
                    .createUnmarshaller();
        } catch (JAXBException e) {
            log.error("Error creating JAXB unmarshaller", e);
            throw new HarvesterError(e);
        }

        List<Source> schemaSources = Lists.newArrayList(
                new StreamSource(this.getClass().getResourceAsStream("OAI-PMH.xsd")),
                new StreamSource(this.getClass().getResourceAsStream("arXivRaw.xsd")));
        try {
            Schema schema = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI)
                    .newSchema(schemaSources.toArray(new Source[schemaSources.size()]));
            unmarshaller.setSchema(schema);
        } catch (SAXException e) {
            log.error("Error creating validation schema", e);
            throw new HarvesterError(e);
        }
    }

    /**
     * Parse the XML response from the arXiv OAI repository.
     *
     * @throws NullPointerException if xmlResponse is null
     * @throws ParseException if parsing fails
     */
    public ParsedXmlResponse parse(@NonNull InputStream xmlResponse) {

        OAIPMHtype unmarshalledResponse;
        try {
            unmarshalledResponse = (OAIPMHtype) unmarshaller.unmarshal(xmlResponse);
        } catch (Exception e) {
            log.error("Error unmarshalling XML response from repository", e);
            throw new ParseException(e);
        }

        ParsedXmlResponse.ParsedXmlResponseBuilder responseBuilder = ParsedXmlResponse.builder();

        responseBuilder.responseDate(toZonedDateTime(unmarshalledResponse.getResponseDate()));



        return null;
    }


    @VisibleForTesting ZonedDateTime toZonedDateTime(XMLGregorianCalendar xmlGregorianCalendar) {
        return xmlGregorianCalendar.toGregorianCalendar().toZonedDateTime();
    }
}
