package io.github.mikesaelim.arxivoaiharvester.xml;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import io.github.mikesaelim.arxivoaiharvester.exception.*;
import io.github.mikesaelim.arxivoaiharvester.model.data.ArticleMetadata;
import io.github.mikesaelim.arxivoaiharvester.model.data.ArticleVersion;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.openarchives.oai._2.OAIPMHerrorType;
import org.openarchives.oai._2.OAIPMHerrorcodeType;
import org.openarchives.oai._2.OAIPMHtype;
import org.xml.sax.SAXException;

import javax.xml.XMLConstants;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.UnmarshalException;
import javax.xml.bind.Unmarshaller;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import java.io.File;
import java.io.InputStream;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Map;

/**
 * Parses the XML response from arXiv's OAI repository into a {@link ParsedXmlResponse}.  The XML response must
 * <ul>
 *     <li>satisfy the OAI-PMH v2.0 XML schema,</li>
 *     <li>be a response for either the verb "GetRecord" or the verb "ListRecords", and</li>
 *     <li>have metadata satisfying arXiv's XML schema for the "arXivRaw" metadata format (the current version of that
 *     is 2014-06-24).</li>
 * </ul>
 *
 * Internally, the XML is parsed in two steps:
 * <ol>
 *     <li>the XML is unmarshalled into autogenerated data objects by the JAXB parser, and then </li>
 *     <li>these data objects are parsed into {@link ArticleVersion}, {@link ArticleMetadata}, and
 *     {@link ParsedXmlResponse} objects.</li>
 * </ol>
 * Additionally, we have to deal with corrupted XML input that contains spurious line breaks in the middle of some of
 * the string values.  For this reason, we normalize the string values that we extract.
 *
 * TODO sample usage
 */
@Slf4j
public class XMLParser {

    // TODO: handle warnings, errors, etc. from the parser
    // TODO: handle error responses from the repository

    private Unmarshaller unmarshaller;

    private static final RepositoryErrorSeverityComparator repositoryErrorSeverityComparator =
            new RepositoryErrorSeverityComparator();

    /**
     * Constructs a new XML parser by initializing the JAXB unmarshaller and setting up the XML validation.
     *
     * @throws HarvesterError if there are any problems
     */
    public XMLParser() {
        try {
            unmarshaller = JAXBContext.newInstance("org.openarchives.oai._2:org.arxiv.oai.arxivraw")
                    .createUnmarshaller();
        } catch (JAXBException e) {
            log.error("Error creating JAXB unmarshaller", e);
            throw new HarvesterError(e);
        }

        List<Source> schemaSources = Lists.newArrayList(
                new StreamSource(this.getClass().getResourceAsStream("OAI-PMH.xsd")),
                new StreamSource(this.getClass().getResourceAsStream("arXivRaw.xsd")));
        try {
            Schema schema = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI)
                    .newSchema(schemaSources.toArray(new Source[schemaSources.size()]));
            unmarshaller.setSchema(schema);
        } catch (SAXException e) {
            log.error("Error creating validation schema", e);
            throw new HarvesterError(e);
        }
    }

    /**
     * Parse the XML response from the arXiv OAI repository.
     *
     * @throws NullPointerException if xmlResponse is null
     * @throws ParseException if parsing fails
     */
    public ParsedXmlResponse parse(@NonNull InputStream xmlResponse) {

        OAIPMHtype unmarshalledResponse;
        try {
            unmarshalledResponse = (OAIPMHtype) unmarshaller.unmarshal(xmlResponse);
        } catch (Exception e) {
            log.error("Error unmarshalling XML response from repository", e);
            throw new ParseException(e);
        }

        ParsedXmlResponse.ParsedXmlResponseBuilder responseBuilder = ParsedXmlResponse.builder()
                .responseDate(toZonedDateTime(unmarshalledResponse.getResponseDate()));


        // Parse any errors
        List<OAIPMHerrorType> errors = Lists.newArrayList(unmarshalledResponse.getError());
        if (!errors.isEmpty()) {
            errors.sort(repositoryErrorSeverityComparator);

            // ID_DOES_NOT_EXIST and NO_RECORDS_MATCH are not considered errors, and simply result in an empty result set
            if (errors.get(0).getCode() == OAIPMHerrorcodeType.ID_DOES_NOT_EXIST ||
                    errors.get(0).getCode() == OAIPMHerrorcodeType.NO_RECORDS_MATCH) {
                return responseBuilder.build();
            }

            // Produce error report
            StringBuilder errorStringBuilder = new StringBuilder("Received error from repository: \n");
            errors.stream().forEach(error ->
                    errorStringBuilder.append(error.getCode().value()).append(" : ").append(error.getValue()).append("\n"));
            String errorString = errorStringBuilder.toString();

            // Throw an exception corresponding to the most severe error
            switch (errors.get(0).getCode()) {
                case BAD_ARGUMENT:
                    throw new BadArgumentException(errorString);
                case BAD_RESUMPTION_TOKEN:
                    throw new BadResumptionTokenException(errorString);
                case BAD_VERB:
                case CANNOT_DISSEMINATE_FORMAT:
                case NO_METADATA_FORMATS:
                case NO_SET_HIERARCHY:
                default:
                    throw new RepositoryError(errorString);
            }
        }






        return null;
    }


    @VisibleForTesting ZonedDateTime toZonedDateTime(XMLGregorianCalendar xmlGregorianCalendar) {
        return xmlGregorianCalendar.toGregorianCalendar().toZonedDateTime();
    }
}
